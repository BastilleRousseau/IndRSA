# 
# # ## Package creation - move to the beginning of the crossing count 
# install.packages("devtools")
# library("devtools")
# devtools::install_github("klutometis/roxygen")
# library(roxygen2)
# setwd("C:/Users/Guillaume/OneDrive/Elephant/Analysis/RSF")
# create("IndRSA")
# # # 
# # # 
# # # Add Files 
# setwd("./IndRSA")
# document()
# 
# # Create pdf 
 pack <- "IndRSA"
 path <- find.package(pack)
 system(paste(shQuote(file.path(R.home("bin"), "R")),"CMD", "Rd2pdf", shQuote(path)))
# 
# 
# 
# 
# ####################################
# #Clean model (#Taken from: https://www.r-bloggers.com/trimming-the-fat-from-glm-models-in-r/)
# ###################################
#' Remove elements from glm object to save space
#'
#' Remove elements from glm objects (Taken from: https://www.r-bloggers.com/trimming-the-fat-from-glm-models-in-r/)
#' @param cm A glm object
#' @return A glm object
#' @export
cmodel = function(cm) { 
  cm$y = c()
  cm$model = c()
  cm$residuals = c()
  cm$fitted.values = c()
  cm$effects = c()
  cm$qr = c()  
  cm$linear.predictors = c()
  cm$weights = c()
  cm$prior.weights = c()
  cm$data = c()
  cm
}

#' Apply a list of candidate models to a single individual  
#'
#' Apply a list of candidate models to a single individual 
#' @param sub A subset of data from a single individual
#' @param form_ls A list of formulas for the different candidate models
#' @param cleamModel Whether the model should be "cleaned" to save memory space
#' @param method Weither typical glm or bias-reduction glm should be fitted (see package brglm)
#' @return A list of glm objects
#' @export
rsf_mod<-function(sub, form_ls, cleanModel=F, method=method) { 
  out<-lapply(1:length(form_ls), function(x) brglm::brglm(form_ls[[x]], data=sub, family=binomial, link="logit", method=method, control.glm=glm.control(maxit=1000)))
  out2<-unlist(lapply(out, logLik))
  try(out3<-lapply(out, function(x) sqrt(diag(vcov(x)))))
  if (cleanModel) (out<-lapply(out, cmodel))
  return(list(out, out2, out3))
}

#' Apply a list of candidate models to multiple individuals  
#'
#' Apply rsf_mod to each individual of a dataset 
#' @param id A vector indicating the individuals
#' @param data The dataset containing all data
#' @param form_ls A list of formulas for the different candidate models
#' @param cleamModel Whether the model should be "cleaned" to save memory space (default = F)
#' @param method Weither typical glm or bias-reduction glm should be fitted (default="glm.fit) (see package brglm)
#' @return A list of list of glm objects
#' @export
#' @examples 
#' Add something
rsf_ind<-function(id,data, form_ls, cleanModel=F, method="glm.fit"  ) { #id is a vector of nrow(data)
  if(length(id) != nrow(data)) (stop("id should be the same length as data"))
  id1<-sort(unique(id))
  out<-pbapply::pblapply(1:length(id1), function(x) rsf_mod(sub=data[id==id1[x],], form_ls=form_ls, method=method, cleanModel=cleanModel))
  names(out)<-id1
  return(out)  
}


#' Identify potential individual with bad fits based on coefficients and model convergence  
#'
#' Identify potential individual with bad fits based on coefficients and model convergence 
#' @param mod_ls A list of list of model generated by rsf_ind
#' @param cutoff Value a coeffiecient may take to indicate bad fit (default=1000)
#' @return A list with first element giving individuals with bad fits based on coefficients and second element containing individuals with bad fit based on convergence
#' @export
#' @examples 
#' Add something
bad_fit<-function(mod_ls, cutoff=1000) {
  tt<-unlist(lapply(mod_ls, function(x) sum(abs(unlist(lapply(x[[1]], coef)))>cutoff, na.rm=T)))
  tt2<-unlist(lapply(mod_ls, function(x) sum(unlist(lapply(x[[1]], function(y) y$converged))==FALSE, na.rm=T)))
  names(tt)<-names(mod_ls)
  names(tt2)<-names(mod_ls)
  return(list(tt[which(tt>0)],tt2[which(tt2>0)]  ))
}

#' Identify potential individual with bad fits based on coefficients and model convergence for a specific model 
#'
#' Identify potential individual with bad fits based on coefficients and model convergence 
#' @param mod_ls A list of list of model generated by rsf_ind
#' @param cutoff Value a coeffiecient may take to indicate bad fit (default=1000)
#' @param m model number (based on number in list of formula provided to rsf_ind)
#' @return A list with first element giving individuals with bad fits based on coefficients and second element containing individuals with bad fit based on convergence
#' @export
#' @examples 
#' Add something
bad_fit1<-function(mod_ls, cutoff=1000, m=1) {
  tt<-unlist(lapply(mod_ls, function(x) sum(abs(coef(x[[1]][[m]]))>cutoff, na.rm=T)))
  tt2<-unlist(lapply(mod_ls, function(x) sum(x[[1]][[m]]$converged==FALSE, na.rm=T)))
  names(tt)<-names(mod_ls)
  names(tt2)<-names(mod_ls)
  return(list(tt[which(tt>0)],tt2[which(tt2>0)]  ))
}


#' Remove potential individual with bad fits based on coefficients
#'
#' Remove potential individual with bad fits based on coefficients 
#' @param mod_ls A list of list of model generated by rsf_ind
#' @param cutoff Value a coeffiecient may take to indicate bad fit (default=1000)
#' @return A list excluding individual with bad fits. 
#' @export
rm_bad_fit<-function(mod_ls, cutoff=1000) {
  tt<-unlist(lapply(mod_ls, function(x) sum(abs(unlist(lapply(x[[1]], coef)))>cutoff, na.rm=T)))
  tt2<-which(tt==0)
  return(mod_ls[tt2])
}

#' Remove potential individual with bad fits based on coefficients for a specific model 
#'
#' Remove potential individual with bad fits based on coefficients 
#' @param mod_ls A list of list of model generated by rsf_ind
#' @param cutoff Value a coeffiecient may take to indicate bad fit (default=1000)
#' @param m model number (based on number in list of formula provided to rsf_ind)
#' @return A list excluding individual with bad fits. 
#' @export
rm_bad_fit1<-function(mod_ls, cutoff=1000, m=1) {
  tt<-unlist(lapply(mod_ls, function(x) sum(abs(coef(x[[1]][[m]]))>cutoff, na.rm=T)))
  tt2<-which(tt==0)
  return(mod_ls[tt2])
}

#' Remove potential individual with bad fits based on model convergence 
#'
#' Remove potential individual with bad fits based on model convergence 
#' @param mod_ls A list of list of model generated by rsf_ind
#' @return A list excluding individual with bad fits. 
#' @export
rm_conv_fit<-function(mod_ls) {
  tt<-unlist(lapply(mod_ls, function(x) sum(unlist(lapply(x[[1]], function(y) y$converged))==FALSE, na.rm=T)))
  tt2<-which(tt==0)
  return(mod_ls[tt2])
}

#' Remove potential individual with bad fits based on model convergence for a specific model 
#'
#' Remove potential individual with bad fits based on model convergence 

#' @param m model number (based on number in list of formula provided to rsf_ind)
#' @return A list excluding individual with bad fits. 
#' @export
rm_conv_fit1<-function(mod_ls, m=1) {
  tt<-unlist(lapply(mod_ls, function(x) sum(x[[1]][[m]]$converged==FALSE, na.rm=T)))
  tt2<-which(tt==0)
  return(mod_ls[tt2])
}


#' Perform model selection over all individuals  
#'
#' Perform AIC model selection over all individuals by adding up likelihood of individual model (based code partly taken from package AICcmodavg) 
#' @param mod_ls A list of list of model generated by rsf_ind
#' @param cutoff A cutoff value to exclude individuals with bad fit, default = -1 indicating model that did not converge will be excluded. Values > 0 will exclude based on coefficient values
#' @return A AIC model selection table
#' @export
#' @examples 
#' Add something
aictab_ind<-function(mod_ls, cutoff=-1) { 
  if(cutoff>0) {mod_ls<-rm_bad_fit(mod_ls, cutoff=cutoff)}
  if(cutoff==-1) {mod_ls<-rm_conv_fit(mod_ls)}
  Aiccf<-function(k, n, loglik) {
    2*k-2*loglik+(2*k*(k+1))/(n-k-1)}
  
  ll_ls<-function(mod_ls) {
    n_mod<-length(mod_ls[[1]][[1]])
    n_id<-length(mod_ls)
    ll_ls<-unlist(lapply(1:n_mod, function(y) sum(unlist(lapply(mod_ls, function(x) x[[2]][y])))))
    return(ll_ls)
  }
  
  n_mod<-length(mod_ls[[1]][[1]])
  n_id<-length(mod_ls)
  #h <- function(w) if( any( grepl( "is.na", w) ) ) invokeRestart( "muffleWarning" )
  Results <- NULL
  Results <- data.frame(Modnames = 1:n_mod)
  Results$LL <-ll_ls(mod_ls)
  Results$K <- unlist(lapply(mod_ls[[1]][[1]], function(x) length(coef(x))))
  Results$AICc <- Aiccf(Results$K, n_id, Results$LL)
  Results$Delta_AICc <- Results$AICc - min(Results$AICc)
  Results$ModelLik <- exp(-0.5 * Results$Delta_AICc)
  Results$AICcWt <- Results$ModelLik/sum(Results$ModelLik)
  return(Results)
}



#' Extract population average of top model and extract individual coefficients  
#'
#' Extract population average of top model and extract individual coefficients. Population average can be calculated based on bootstrap (Prokopenko et al. 2016 JAppEco) or weighted based on standard errors (Murtaugh 2007 Ecology)   
#' @param m model number (based on number in list of formula provided to rsf_ind)
#' @param mod_ls A list of list of model generated by rsf_ind
#' @param cutoff A cutoff value to exclude individuals with bad fit, default = -1 indicating model that did not converge will be excluded. Values > 0 will exclude based on coefficient
#' @param method If = "boot", population average is based on bootstrap, if = "murtaugh" based on standard errors weighting. See Prokopenko et al 2016 or Murtaugh 2007 for details. 
#' @param nboot Number of bootstrap iterations, default = 1000. Only applicable if method = "boot".  
#' @return A list containing a table population average with confidence intervals and a table of individual coefficients
#' @export
#' @examples 
#' Add something
pop_avg<-function(m=1, mod_ls,cutoff=0, method="boot", nboot=1000) {
  if(cutoff>0) {mod_ls<-rm_bad_fit1(mod_ls, cutoff=cutoff, m=m)}
  if(cutoff==-1) {mod_ls<-rm_conv_fit1(mod_ls,  m=m)}
  i<-length(mod_ls)
  add_weights<-function(x, name=name) {
    t<-data.frame(table(x$name))
    t$Freq<-1/t$Freq
    out<-merge(x, t, by.x="name", by.y="Var1")
    return(out)
  }
  co<-lapply(1:i, function(x) data.frame(t(data.frame(coef(mod_ls[[x]][[1]][[m]])))))
   coef2<-plyr::rbind.fill(co)
  rownames(coef2)<-names(mod_ls)
  coef2$name<-matrix(unlist(strsplit(as.character(rownames(coef2)), "_")), ncol=2, byrow=T)[,1]
  coef2$ID<-names(mod_ls)
  coef2<-add_weights(coef2)

  if(method=="boot") {
    mean_ci_boot<-function(boot, lci=0.025, uci=0.975) { 
      n<-length(boot[[1]])
      out<-data.frame()
      for (i in 1:n) {
        out<-rbind(out, 
                   c(mean(unlist(lapply(boot, function(x) x[i]))),
                     quantile(unlist(lapply(boot, function(x) x[i])), probs=c(lci, uci), na.rm=T)))
      }
      names(out)<-c("Mean", "LCI", "UCI")
      rownames(out)<-names(boot[[1]])
      return(out)
    }
    
    boot<-list()
    for(i in 1:nboot){
      boot[[i]]<-apply(coef2[sample(nrow(coef2), nrow(coef2), replace=T, prob=coef2$Freq), 2:(ncol(coef2)-2) ],2, median, na.rm=T) #Modify
    }
    pop<-mean_ci_boot(boot)
  }
  
  if(method=="murtaugh") { 
    se<-lapply(1:i, function(x) data.frame(t(data.frame(mod_ls[[x]][[3]][[m]]))))
    se2<-plyr::rbind.fill(se)
    cc<-coef2[,2:(ncol(coef2)-2)]
    ls<-lapply(1:ncol(se2), function(x) lm(cc[,x]~1, weights=1/se2[,x]^2))
    pop<-data.frame(matrix(unlist(lapply(ls, function(x) cbind(coef(x), confint(x, method="Wald")))), byrow=3, ncol=3))
    names(pop)<-c("Mean", "LCI", "UCI")
    rownames(pop)<-names(coef2[,2:(ncol(coef2)-2)])
  }
  
  pop$Prop<-unlist(lapply(1:nrow(pop), function(x) ifelse(pop[x,1]>0, sum(coef2[,(x+1)]>0, na.rm=T),sum(coef2[,(x+1)]<0, na.rm=T))/length(mod_ls))) #Not useful since all are below zero
  return(list(pop, coef2))
}



#' Extract individual coefficients  
#'
#' Extract individual coefficients. 
#' @param m model number (based on number in list of formula provided to rsf_ind)
#' @param mod_ls A list of list of model generated by rsf_ind
#' @param cutoff A cutoff value to exclude individuals with bad fit, default = -1 indicating model that did not converge will be excluded. Values > 0 will exclude based on coefficient
#' @return A list containing a table population average with confidence intervals and a table of individual coefficients
#' @export
#' @examples 
#' Add something
ind_coef<-function(m=1, mod_ls,cutoff=0) {
  if(cutoff>0) {mod_ls<-rm_bad_fit1(mod_ls, cutoff=cutoff, m=m)}
  if(cutoff==-1) {mod_ls<-rm_conv_fit1(mod_ls,  m=m)}
  i<-length(mod_ls)
  add_weights<-function(x, name=name) {
    t<-data.frame(table(x$name))
    t$Freq<-1/t$Freq
    out<-merge(x, t, by.x="name", by.y="Var1")
    return(out)
  }
  co<-lapply(1:i, function(x) data.frame(t(data.frame(coef(mod_ls[[x]][[1]][[m]])))))
  coef2<-plyr::rbind.fill(co)
  rownames(coef2)<-names(mod_ls)
  coef2$name<-matrix(unlist(strsplit(as.character(rownames(coef2)), "_")), ncol=2, byrow=T)[,1]
  coef2$ID<-names(mod_ls)
  coef2<-add_weights(coef2)
  return(coef2)
}


#' Evaluate ratio of used and random locations of individuals in a RSF table  
#'
#' Evaluate ratio of used and random locations of individuals in a RSF table
#' @param id A vector of individual for each observation
#' @param value A vector indicating if each observation is used (=1) or random(=0)
#' @return A list indicating the range in ratio, range in random locations, and range in used location. 
#' @export
eval_ratio<-function(id, value) {
  tt<-table(id, value)
  prop<-tt[,1]/tt[,2]
  out<-list(quantile(prop), quantile(tt[,1]), quantile(tt[,2]))
  names(out)<-c("Prop", "#Rnd", "#Used")
  return(out)
}  


#' Resample a RSF table to keep constant ratio of used/random locations accross individuals
#'
#' Resample a RSF table to keep constant ratio of used/random locations accross individuals. Resampling is done with replacement. 
#' @param data The RSF dataset to resample
#' @param id A vector of individual for each observation
#' @param value A vector indicating if each observation is used (=1) or random(=0)
#' @param ratio The ratio of random:used location (default =3, meaning 3 random locations for each used location)
#' @return A RSF dataset
#' @export
resample_rsf<-function(data, id="Id_Year", value="Value", ratio=3) {
  id1<-sort(unique(data[,id]))
  tt<-function(sub, value=value, ratio=ratio) {
    sub1<-sub[sub[,value]==1,]
    sub0<-sub[sub[,value]==0,]
    sub0a<-sub0[sample(1:nrow(sub0), nrow(sub1)*ratio, replace=T),]
    return(rbind(sub1,sub0a))
  }
  out<-data.frame()
  pb = txtProgressBar(min = 0, max = length(id1), initial = 0, style=3) 
  for (i in 1:length(id1)) {
    sub<-data[data[,id]==id1[i],]
    sub2<-tt(sub, value=value, ratio)
    out<-rbind(out, sub2)
    setTxtProgressBar(pb,i)
  }
  return(out)
}

#' Perform kfold cross-validation at the individual level . 
#'
#' Perform kfold cross-validation at the individual level and return histogram, mean kfold accros individual and min/max value
#' @param m model number (based on number in list of formula provided to rsf_ind)
#' @param mod_ls A list of list of model generated by rsf_ind
#' @param cutoff A cutoff value to exclude individuals with bad fit, default = -1 indicating model that did not converge will be excluded. Values > 0 will exclude based on coefficient
#' @param k number of fold (default = 5)
#' @param nrepet Number of repetitions (default =10)
#' @param nbins Number of bins (default =10)
#' @param jitter Logical, whether to add some random noise to the predictions (useful when the model is fitted on categorica  variables, which can produces error in the ranking process).
#' @param reproducible Logical, whether to use a fixed seed for each repetition.
#' @return A data frame with the correlations (\code{cor}) and the type of value (\code{type}).
#' @export
kfold_ind<-function(m=1, mod_ls, ls=ls, cutoff=0, k=5, nrepet=5, nbins=10, grph=T) {
  if(cutoff>0) {mod_ls<-rm_bad_fit1(mod_ls, cutoff=cutoff, m=m)}
  if(cutoff==-1) {mod_ls<-rm_conv_fit1(mod_ls, m=m)}
  method=mod_ls[[1]][[1]][[1]]$method
  #x<-m
  #form_ls<-ls
  kk<-pbapply::pblapply(mod_ls, function(y) kfoldRSF(y[[1]][[m]], k=k, form_ls=ls, nrepet=nrepet, x=m, method=method, nbins=nbins, random=F))
  mean<-lapply(kk, mean, na.rm=T)
  if (grph) {plot(hist(unlist(mean)))}
  return(c(mean(unlist(mean), na.rm=T), min(unlist(mean), na.rm=T),max(unlist(mean), na.rm=T)))
}

#' Perform kfold cross-validation on a RSF output. 
#'
#' Perform kfold cross-validation on a RSF output. Similar to what is recommended in Boyce 2002. Function developped with Mathieu Basille
#' @param mod A RSF model (glm or glmer)
#' @param k number of fold (default = 5)
#' @param nrepet Number of repetitions (default =10)
#' @param nbins Number of bins (default =10)
#' @param jitter Logical, whether to add some random noise to the predictions (useful when the model is fitted on categorica  variables, which can produces error in the ranking process).
#' @param reproducible Logical, whether to use a fixed seed for each repetition.
#' @return A data frame with the correlations (\code{cor}) and the type of value (\code{type}).
#' @export
kfoldRSF <- function(mod, k = 5, nrepet = 10, nbins = 10,  jitter = TRUE,
                     random = TRUE, method=method, x=m, form_ls=ls, reproducible = TRUE)
{
  if (!inherits(mod, c("glm", "mer", "glmerMod")))
    stop("Model of class '(g)lm' or '(g)lmer' expected")
  if (inherits(mod, c("glmerMod")))
    require(lme4)
  dt <- model.frame(mod)
  kfold <- rd <- numeric(length = nrepet)
  resp <- as.character(attr(terms(mod), "variables"))[attr(terms(mod),
                                                           "response") + 1]
  for (i in 1:nrepet) {
    dt$sets <- "train"
    if(reproducible)
      set.seed(i)
    dt$sets[sample(which(dt[, resp] == 1), sum(dt[, resp] ==
                                                 1)/k)] <- "test"
    reg <- update(mod, data = subset(dt, sets == "train"))
    cof<-coef(reg)
    cof[is.na(cof)]<-0
    if (inherits(mod, "glm"))
      predall <- exp(as.numeric(model.matrix(terms(reg),
                                             dt) %*% cof))
    else if (inherits(mod, "glmerMod"))
      predall <- exp(as.numeric(model.matrix(terms(reg),
                                             dt) %*% fixef(reg)))
    if (jitter) {
      if(reproducible)
        set.seed(i)
      predall <- jitter(predall)
    }
    quant <- quantile(predall[dt[, resp] == 0], probs = seq(from = 0,
                                                            to = 1, length.out = nbins + 1))
    quant[1] <- -Inf
    quant[length(quant)] <- Inf
    int <- factor(findInterval(predall[dt$sets == "test"],
                               quant), levels = 1:nbins)
    kfold[i] <- cor(1:nbins, table(int), method = "spearman")
    if (random) {
      if (reproducible)
        set.seed(i)
      dt$sets[sample(which(dt[, resp] == 0), sum(dt[, resp] ==
                                                   1)/k)] <- "rd"
      int <- factor(findInterval(predall[dt$sets == "rd"],
                                 quant), levels = 1:nbins)
      rd[i] <- cor(1:nbins, table(int), method = "spearman")
    }
  }
  if (random)
    return(data.frame(kfold = c(kfold, rd), type = rep(c("obs",
                                                         "rand"), each = nrepet)))
  else return(kfold)
}


# 
# rsf_mod2<-function(sub, form_ls, cleanModel=F) { 
#   out<-lapply(1:length(form_ls), function(x) glm(form_ls[[x]], data=sub, family=binomial))
#   if (cleanModel) (out<-lapply(out, cleanModel))
#   return(out)
# }
# 
# 
# rsf_ind2<-function(id,data, form_ls, cleanModel=F) { #id is a vector of nrow(data)
#   if(length(id) != nrow(data)) (stop("id should be the same length as data"))
#   id1<-sort(unique(id))
#   out<-pbapply::pblapply(1:length(id1), function(x) rsf_mod2(sub=data[id==id1[x],], form_ls=form_ls, cleanModel=cleanModel))
#   names(out)<-id1
#   return(out)  
# }
# #coef2score
# coef2score<-function(popavg) {
#   out<-data.frame(matrix(unlist(lapply(3:(ncol(popavg)-2), function(x) exp(popavg[,2]+popavg[,x]))), nrow=nrow(popavg), ncol=length(3:(ncol(popavg)-2))))
#   names(out)<-names(popavg[,c(3:(ncol(popavg)-2))])
#   out$ID<-popavg[,"ID"]
#   out$Freq<-popavg[,"Freq"]
#   return(out)
# }